<!DOCTYPE html>
<html>
<head>
    <title>hrorm</title>
    <style>
    body {
        width: 65em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
    div.java {
        font-family: monospace;
        background-color: LightBlue;
        font-size: 105%;
    }
    div.disclaimer {
        color: DarkGrey;
        font-size: 75;
    }
    table.gridtable {
        color:#333333;
        border-width: 1px;
        border-color: #666666;
        border-collapse: collapse;
    }
    table.gridtable th {
        border-width: 1px;
        padding: 8px;
        border-style: solid;
        border-color: #666666;
        background-color: #dedede;
    }
    table.gridtable td {
        border-width: 1px;
        padding: 8px;
        border-style: solid;
        border-color: #666666;
        background-color: #ffffff;
    }

</style>
</head>
<body>
<h1>hrorm</h1>

<p>Hrorm is the Hand Rolled Object Relational Mapper.</p>

<p>Hrorm is a Java library.</p>

<p><a href="https://github.com/ojplg/hrorm">Code</a> - <a href="/javadocs/site/apidocs/index.html">Javadocs</a> </p>

<p>
Maven:
    <pre>
    &lt;dependency>
        &lt;groupId&gt;org.hrorm&lt;/groupId&gt;
        &lt;artifactId&gt;hrorm&lt;/artifactId&gt;
        &lt;version&gt;0.1.0-rc2&lt;/version&gt;
    &lt;/dependency>
</pre>
</p>

<h2>Basics</h2>

<p>Hrorm provides a concise, declarative, somewhat type-checked interface for creating Data Access Objects
(DAOs).</p>

<h2>Quick Start</h2>

<p>Suppose you are working on a program for managing recipes that has a domain model that looks like this.</p>

<pre>
<div class="java">
    class Author {
        Long id;
        String name;
    }

    class Recipe {
        Long id;
        String name;
        Author author;
        List&lt;Ingredient&gt; ingredients;
    }

    class Ingredient {
        Long id;
        long recipeId;
        String name;
        long amount;
    }

</div>
</pre>

<p>You might ask yourself: how will I persist such a rich, complex model? And you might think ... I know,
    I'll put everything into a <code>List</code> and call <code>serialize()</code> and write that to a file on disk.
    How many recipes and simultaneous users are we expecting to support anyway?
</p>

<p>But instead, you come up with the following relational schema.</p>

<img src="recipe_schema.png">

<p>Because you are the absolute Empress of Overkill.</p>

<p>Now some might think to use <a href="http://hibernate.org/">Hibernate</a> or
<a href="http://www.mybatis.org/mybatis-3/">Mybatis</a> or something, but no, you
are a real glutton for punishment, so you decide to use hrorm.</p>

<p>To use hrorm you would write some code like this.</p>

<div class="disclaimer">Disclaimer: Yeah, I assume that your schema has some sequences that are not in the picture above.
    Also, you should have created getters and setters for all of the fields on your object model or
    used <a href="https://projectlombok.org/">Lombok</a> or something.</div>

<pre>
<div class="java">
    DaoBuilder&lt;Author&gt; authorDaoBuilder = new DaoBuilder&lt;&gt;("AUTHOR", Author::new)
            .withPrimaryKey("ID", "AUTHOR_SEQUENCE", Author::getId, Author::setId)
            .withStringColumn("NAME", Author::getName, Author::setName);

    DaoBuilder&lt;Ingredient&gt; ingredientDaoBuilder = new DaoBuilder&lt;&gt;("INGREDIENT", Ingredient::new)
            .withPrimaryKey("ID", "INGREDIENT_SEQUENCE", Ingredient::getId, Ingredient::setId)
            .withIntegerColumn("RECIPE_ID", Ingredient::getRecipeId, Ingredient::setRecipeId)
            .withStringColumn("NAME", Ingredient::getName, Ingredient::setName);

    DaoBuilder&lt;Recipe&gt; recipeDaoBuilder = new DaoBuilder&lt;&gt;("RECIPE", Recipe::new)
            .withPrimaryKey("ID", "RECIPE_SEQUENCE", Recipe::getId, Recipe::setId)
            .withStringColumn("NAME", Recipe::getName, Recipe::setName)
            .withJoinColumn("AUTHOR_ID", Recipe::getAuthor, Recipe::setAuthor, authorDaoBuilder)
            .withChildren("RECIPE_ID", Ingredient::setRecipeId, Recipe::getIngredients, Recipe::setIngredients, ingredientDaoBuilder);

</div>,
</pre>

<p>
    That's pretty painful. Thank God for autocompletion. Once that's done, and assuming you have some way to make
    a <code>java.sql.Connection</code> object now you can actually make a <code>Dao</code>. Then you can
    write some code like this.
</p>

<pre>
<div class="java">
    Connection connection = // somehow this happened

    Dao&lt;Author&gt; authorDao = authorDaoBuilder.buildDao(connection);

    Author juliaChild = new Author();
    juliaChild.setName("Julia Child");

    authorDao.insert(juliaChild);

    Ingredient carrots = new Ingredient();
    carrots.setName("Carrots");
    carrots.setAmount(4L);
    Ingredient onions = new Ingredient();
    onions.setName("Onions");
    onions.setAmount(2L);
    Ingredient beef = new Ingredient();
    beef.setName("Cow");
    beef.setAmount(1L);

    Recipe beefStew = new Recipe():
    beefStew.setName("Beef Stew");
    beefStew.setAuthor(juliaChild);
    beefStew.setIngredients(Arrays.asList(carrots, onions, beef));

    Dao&lt;Recipe&gt; recipeDao = recipeDaoBuilder.buildDao(connection);
    recipeDao.insert(beefStew);

</div>
</pre>

<p>Of course, <code>Dao</code>s can do more than just <code>insert</code>. They can also do
<code>update</code>, <code>delete</code>, and various forms of <code>select</code>.</p>

<p>And really, that's all there is to hrorm.</p>

<h2>Comparison with Other ORM Tools</h2>

<table class="gridtable">
    <thead>
        <tr>
            <th></th>
            <th>Hibernate</th>
            <th>Mybatis</th>
            <th>hrorm</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td>Fully-featured</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Wide community support</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Rich documentation</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Battle tested in major enterprise deployments</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Supports your schema and object model without constraints</td>
            <td>Maybe</td>
            <td>Somewhat</td>
            <td>Absolutely not</td>
        </tr>
    </tbody>

</table>

<h2>Things hrorm Does Not Do</h2>

<ul>
    <li>Any kind of caching.</li>
    <li>Attempt to minimize database chatter by lazy-loading or object change tracking. Hrorm assumes that if
    you make a call to a <code>Dao</code> it's because you want to read or write something in the database.</li>
    <li>Transaction management. Transactions are for applications, not for hrorm.</li>
    <li>Pollute your code with vexing annotations.</li>
    <li>Involve itself with any XML or other configuration. Hrorm thinks Java is a better language than XML.</li>
    <li>Take over your application with background threads or expect some kind of container to exist. Hrorm is a library,
    if you do not call the methods, nothing happens.</li>
    <li>Reflection.</li>
    <li>Invent its own query language.</li>
    <li>Expect you to write SQL yourself.</li>
    <li>Manage validity constraints to your schema or object model.</li>
    <li>Declare checked exceptions in its client facing interfaces.</li>
</ul>

<h2>Designing for hrorm</h2>

<p>Hrorm only works on a restricted entity model. It expects your Java object model and your SQL schema to
work a particular way. If this does not work for you, than neither will hrorm.</p>

<h4>Java Object Model</h4>

<ul>
    <li>Every object should have a <code>Long</code> identifier field that will be used as a primary key.
    Hrorm expects that this is a nullable field and that null means unpersisted. (Though really, this is not
    completely necessary.) Hrorm will populate this field from a sequence (see restrictions on schema below) and will use
    it when issuing updates.</li>
    <li>Hrorm mostly expects to work with Javabean like entities with public getters and setters. I suppose
        you could have hrorm work with builder objects and then have immutable entities, but then you would
        have to write some glue code to link it altogether.
    </li>
    <li>Hrorm expects child objects owned by other objects (in a parent-child style relationship) to hold a reference
    to the parent's ID, but not a reference to the parent objects themselves. Hrorm is unsophisticated in dealing
    with circular references.</li>
    <li>Hrorm expects child relationships to be modeled as <code>List</code> types exclusively. No sets or arrays or
    other collections.</li>
</ul>

<h4>SQL Schema</h4>

<ul>
    <li>Hrorm expects every table to have a numeric primary key. No string keys or multiple column keys.
    Hrorm is not really appropriate for a time-series database.</li>
    <li>Hrorm will populate the primary keys on inserts with values it pulls from a sequence. You can
    create a separate sequence for each table, or just have one overall sequence if you want. Hrorm does not
    care, but it wants a sequence for inserts.</li>
</ul>

<p>
At the moment Hrorm supports a limited number of datatypes: integral, strings, booleans, and dates. It should be
easy to add more types, but it is not done yet. Check the javadocs.
</p>

<h2>How hrorm <Ha></Ha>ndles Relations</h2>

<p>One point of a relational database is to preserve the structure of relations between entities.
Hrorm supports two kinds of relationships: a parent-child relation where one object contains a list
of children, and a sibling relationship, where one object expresses a connection with another entity.</p>

<h4>Parent-Child Relations</h4>

<p>These relations are defined by using the <code>DaoBuilder.withChildren()</code> method.</p>

<p>In a parent-child relationship, the child is assumed to be completely dependent on the parent, so
that its very existence depends on the existence of the parent.</p>

<p>Think of the recipe example above. If a recipe is deleted, it makes no sense to preserve the
ingredient rows. So, if a call is made on the recipe <code>Dao.delete()</code> method, all
the ingredients will be deleted too. Likewise, on an update hrorm will make the necessary inserts,
updates, and deletes to the ingredients table to synchronize the object state.</p>

<p>In fact, you would rarely want to instantiate an ingredients <code>Dao</code> directly.
Hrorm will do the work for you.</p>

<p>One tricky thing about these relationships is the reversal in how ownership is expressed between
the database schema and the object model. In the object model, the Hand object has Finger objects. In
the database, the FINGER table has foreign key references to the HAND table. The call to the
<code>DaoBuilder.withChildren()</code> is somewhat tricky as a result. Most of the time, a
<code>DaoBuilder</code> is concerned only with columns on its own table, not so for children objects.</p>

<h4>Sibling Relations</h4>

<p>These relations are defined by using the <code>DaoBuilder.withJoinColumn()</code> method.</p>

<p>These are relations between two objects where one object refers in a dependent, but not
controlling, way.</p>

<p>In the example above, the relationship between an Author and a Recipe is of this type.
A Recipe requires and Author, but neither owns the other.
</p>

<p>Hrorm requires that sibling objects be persisted first, and will not handle transitive persistence
automatically. Likewise, deleting a Recipe will not cause a cascading delete of an Author record.</p>

<p>Note well: Hrorm will do nothing to prevent a dependent sibling from being deleted. The application
code, or database schema constraints, (or both!) must be in place to prevent orphaned records of that type.</p>

<p>If hrorm encounters a place where a dependent record does not exist that is expected, it will throw
an exeption.</p>

<h2>Hrorm and Exceptions</h2>

<p>Hrorm thinks that checked exceptions are a mistake. In an application with a database dependency,
you have three choices:</p>

<ol>
    <li>Have <code>SQLException</code> declared in most methods all over your application.</li>
    <li>Try to handle <code>SQLException</code> somehow when doing interactions with <code>Connection</code>s,
    <code>Statement</code>s, and <code>ResultSet</code>s. How, I do not know.</li>
    <li>Convert <code>SQLException</code> to some other type, preferably of type <code>RuntimeException</code>.</li>
</ol>

<p>
Hrorm opts for method 3.
</p>

<p>Hrorm will throw a <code>HrormException</code> when it has a problem, generally wrapping <code>SQLException</code>.
You can pull the underlying exception from it.
</p>

</body>
</html>
