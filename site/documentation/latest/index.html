<!DOCTYPE html>
<html>
<head>
    <title>hrorm - Documentation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mini.css/3.0.0/mini-default.min.css">
    <link rel="stylesheet" href="/css/hrorm.css">
</head>
<body>


<div class="container">
    <div class="row">

        <div class="col-sm-3">
            <nav id="documentation_navigation">
                <a href="#introduction">Introduction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>

                <a href="#concepts">Concepts</a>
                <a href="#relationships" class="sublink-1">Relationships</a>
                <a href="#parent_child_relations" class="sublink-2">Parent-Child Relations</a>
                <a href="#sibling_relations" class="sublink-2">Sibling Relations</a>
                <a href="#transactions" class="sublink-1">Transactions</a>

                <a href="#daobuilders">DaoBuilders</a>
                <a href="#one_table" class="sublink-1">One Table</a>
                <a href="#sibling_relations" class="sublink-1">Sibling Relations</a>
                <a href="#parent_child_relations" class="sublink-1">Parent Child Relations</a>
                <a href="#immutable_models" class="sublink-1">Immutable Models</a>
                <a href="#constraints" class="sublink-1">Constraints</a>
                <a href="#validation" class="sublink-1">Validation</a>

                <a href="#daos">Daos</a>
                <a href="#insert" class="sublink-1">Insert</a>
                <a href="#select" class="sublink-1">Select</a>
                <a href="#update" class="sublink-1">Update</a>
                <a href="#delete" class="sublink-1">Delete</a>
                <a href="#atomic" class="sublink-1">Atomic</a>
                <a href="#sql" class="sublink-1">SQL</a>


                <a href="#miscellaneous">Miscellaneous</a>
                <a href="#exceptions" class="sublink-1">Exceptions</a>
                <a href="#logging" class="sublink-1">Logging</a>
                <a href="#visibility" class="sublink-1">Visibility</a>

            </nav>
        </div>

        <div class="col-sm-9">

            <a name="introduction"></a>
            <h2>Introduction</h2>
            <hr>

            <p>Interactions with hrorm have two major points: building <code>Dao</code> objects and then using them.</p>

            <p><code>Dao</code> building is accomplished with the aptly named <code>DaoBuilder</code> class.
                <code>DaoBuilder</code> objects are part of the one-time (static, singleton) initiation of
                your application. There is little point in having more than one builder of any entity type.
                Of course, some care must be taken: by their nature, <code>DaoBuilder</code> objects are
                mutable, so if you directly expose them to the rest of your application during start up,
                it's possible that you can do something stupid.
            </p>

            <p><code>Dao</code> objects themselves are what perform the actual tasks of persisting and
            instantiating entity objects. To make a <code>Dao</code> requires a <code>Connection</code>
            object. Since a <code>Dao</code> keeps a stateful <code>Connection</code> to the underlying
            data store, it is dangerous to share instances across threads. Generally, the idea is to
            instantiate a <code>Dao</code> when you need it, and then allow it to be garbage collected.
            It is up the application itself to deal with reaping the <code>Connection</code>, with some exceptions
            noted below.</p>

            <p>Also take a look at the <a href="/#quick_start">Quick Start</a> and <a href="/javadocs/latest">Javadocs</a>.</p>

            <p>This page contains more nuts and bolts about what and how hrorm does what it does. For more
            on the why, return to the <a href="/">hrorm home page</a>.</p>

            <a name="concepts"></a>
            <h2>Concepts</h2>
            <hr>

            <div class="card fluid">

                <a name="relationships"></a>
                <h3>Relationships</h3>

                <hr>

                <p>One point of using a relational database as opposed to a document store or other mechanism
                    is to preserve the structure of relations between entities.
                    Hrorm supports two kinds of relationships: a parent-child relation where one object contains a list
                    of children, and a sibling relationship, where one object expresses a connection with another
                    entity.</p>

                <a name="parent_child_relations"></a>
                <h4>Parent-Child Relations</h4>

                <p>These relations are defined by using the <code>DaoBuilder.withParent()</code> and
                    <code>DaoBuilder.withChildren()</code> methods.</p>

                <p>In a parent-child relationship, the child is assumed to be completely dependent on the parent, so
                    that its very existence depends on the existence of the parent.</p>

                <p>Think of the recipe example above. If a recipe is deleted, it makes no sense to preserve the
                    ingredient rows. So, if a call is made on the recipe <code>Dao.delete()</code> method, all
                    the ingredients will be deleted too. Likewise, on an update hrorm will make the necessary inserts,
                    updates, and deletes to the ingredients table to synchronize the object state.</p>

                <p>In fact, you would rarely want to instantiate an ingredients <code>Dao</code> directly.
                    Hrorm will do the work for you.</p>

                <p>One tricky thing about these relationships is the reversal in how ownership is expressed between
                    the database schema and the object model. In the object model, the Hand object has Finger objects.
                    In the database, the FINGER table has foreign key references to the HAND table. With hrorm, the
                    <code>DaoBuilder</code> object of both the parent and child need to understand
                    the relationship, not just one or the other.</p>

                <a name="sibling_relations"></a>
                <h4>Sibling Relations</h4>

                <p>These relations are defined by using the <code>DaoBuilder.withJoinColumn()</code> method.</p>

                <p>These are relations between two objects where one object refers in a dependent, but not
                    controlling, way.</p>

                <p>In the example above, the relationship between an Author and a Recipe is of this type.
                    A Recipe requires and Author, but neither owns the other.
                </p>

                <p>Hrorm requires that sibling objects be persisted first, and will not handle transitive persistence
                    automatically. Likewise, deleting a Recipe will not cause a cascading delete of an Author
                    record.</p>

                <p>Note well: Hrorm will do nothing to prevent a dependent sibling from being deleted. The application
                    code, or database schema constraints, (or both!) must be in place to prevent orphaned records of
                    that type.</p>

            </div>


            <div class="card fluid">

                <a name="transactions"></a>
                <h3>Transactions</h3>

                <hr>

                <p>For the most part, hrorm tries to stay out of the transaction handling business.
                    Applications know what changes must be transactions, hrorm does not. However, hrorm's
                    commands to insert, update, and delete records can lead to multiple SQL statements
                    being run, due to the handling of parent-child relationships. This means in the case
                    of an error, the database is at risk of coming to an illegal state.</p>

                <p>If nested transactions were supported natively by every database provider,
                    it would probably be correct to wrap database mutations in an internally nested transaction
                    and commit or rollback on completion. This is not possible for every provider,
                    and mechanisms for how to accomplish this are not identical even for databases that
                    do provide for transaction nesting.</p>

                <p>Hrorm does give a minimal amount of support to attempt to alleviate these issues. Hrorm provides
                    a <a href="/javadocs/latest/org/hrorm/Transactor.html"><code>Transactor</code></a> class
                    with a couple of methods to elminate the boilerplate <code>try ... catch ... finally</code>
                    blocks necessary for doing transactions. In keeping with the hrorm ethos, these methods
                    do not declare any checked exceptions. Keep in mind that a <code>Transactor</code> will
                    <b>automatically close its connection</b> whether or not it completes with a commit or a rollback.
                </p>

                <p>In addition, the <code>Dao</code> interface provides cognate methods for <code>insert</code>,
                    <code>update</code>, and <code>delete</code> named <code>atomicInsert</code>,
                    <code>atomicUpdate</code>, and <code>atomicDelete</code>. These methods provide
                    a no-fuss way to do mutations of parent-child relations. However, these methods
                    must be used with care! In addition to a possibly unexpected early commit if these methods
                    are accidentally used in a larger transaction, remember that, as above, these methods
                    will also <b>close the connection</b> they use when complete.</p>

                <p>There is no one-size-fits-all solution to how to marry the problem of database
                    to object mapping with the problems of transactions and atomicity. For this reason,
                    hrorm mostly just tries to stay out of the way.</p>

            </div>



            <a name="daobuilders"></a>
            <h2>Dao Builders</h2>

            <a name="one_table"></a>
            <div class="card fluid">
                <h3>One Table</h3>
                <hr>
                <p>The easiest case for any ORM tool is persisting a single object backed by a single table.
                Let's work on persisting a model for a person that includes the following elements:</p>
                <ul>
                    <li>Name (a string or text)</li>
                    <li>Weight in kilograms (an integer)</li>
                    <li>Height in meters (a decimal)</li>
                    <li>Birthday (a date)</li>
                    <li>High school graduate? (a boolean)</li>
                    <li>Hair color (an enumerated type)</li>
                </ul>

                <p>To model the person entity, we write a Java Person object.</p>

                <pre>
    class Person {
        Long id;
        String name;
        long weight;
        BigDecimal height;
        LocalDateTime birthday;
        boolean isHighSchoolGraduate;
        HairColor hairColor;
    }</pre>

                <p>A few small points.</p>

                <ul>
                    <li>Use your imagination to fill in getters, setters, equals, hashCode, etc.</li>
                    <li>We have one extra field that we did not have in our logical model: an id field that is to be used
                        for persistence.</li>
                    <li>Assume that there is an enumerated type for hair color: <code>HairColor.Black</code>, <code>HairColor.Brown</code>, etc.</li>
                </ul>

                <p>In the database we will create two structures for persisting this class: a table to store the data
                and a sequence to issue the IDs.</p>

                <pre>
    CREATE SEQUENCE PERSON_SEQUENCE;

    CREATE TABLE PERSON_TABLE (
        ID INTEGER PRIMARY KEY,
        NAME TEXT,
        WEIGHT INTEGER,
        HEIGHT DECIMAL,
        BIRTHDAY TIMESTAMP,
        IS_HIGH_SCHOOL_GRADUATE TEXT,
        HAIR_COLOR TEXT
    );</pre>

                <p>Note the somewhat different types than in the Java code. In particular, the boolean and
                enumeration values have become text fields. SQL has a more limited palate for the expression
                of types than Java.</p>

                <p>To translate between the database reprentation and the Java representation, we plan to use
                a <code>Dao</code> object. We could build that directly, but hrorm provides a DaoBuilder
                class that makes things much easier. In hrorm, both <code>Dao</code> objects and their builders
                are parameterized on the type of thing they persist. We start off by simply calling the
                <code>DaoBuilder</code> constructor.</p>

                <pre>
    DaoBuilder&lt;Person&gt; daoBuilder = new DaoBuilder&lt;&gt;("PERSON_TABLE", Person::new);</pre>

                <p>The constructor takes two arguments: the name of the table and a no-argument method for
                creating a new instance of the parameterized type.</p>

                <p>Next, we need to define the primary key for this entity.</p>

                <pre>
    daoBuilder.withPrimaryKey("ID","PERSON_SEQUENCE", Person::getId, Person::setId);</pre>

                <p>The primary key is defined with four elements:</p>

                <ol>
                    <li>The name of the primary key column in the table ("ID")</li>
                    <li>The name of the sequence that populates the primary keys ("PERSON_SEQUENCE")</li>
                    <li>A function that retrieves the primary key (of type <code>Long</code>) from the <code>Person</code> object.</li>
                    <li>A function that can set the primary key onto the object.</li>
                </ol>

                <p>With that covered, we can being to teach the <code>DaoBuilder</code> about the individual data
                elements. First, we will teach it about the name field.</p>

                <pre>
    daoBuilder.withStringColumn("NAME", Person::getName, Person::setName);</pre>

                <p>This explains that that table has a column named "NAME" and that the value in the table can
                be populated from calling <code>getName()</code> on a <code>Person</code>, and that value
                can be set by calling <code>setName()</code>. There are other methods on the <code>DaoBuilder</code>
                for other Java types.</p>

                <p>For the integer weight value (which should actually be a <code>Long</code> or <code>long</code>,
                not an <code>int</code> or <code>short</code>).</p>

                <pre>
    daoBuilder.withIntegerColumn("WEIGHT", Person::getWeight, Person::setWeight);</pre>

                <p>For fractional, decimal, or floating point values, hrorm supports the <code>java.math.BigDecimal</code> type.</p>

                <pre>
    daoBuilder.withBigDecimalColumn("HEIGHT", Person::getHeight, Person::setHeight);</pre>

                <p>For dates and times, hrorm supports the <code>java.time.LocalDateTime</code> type.</p>

<pre>
    daoBuilder.withLocalDateTimeColumn("BIRTHDAY", Person::getBirthday, Person::setBirthday);</pre>

                <p>And similarly for boolean values. Note that the table should declare a text or string value.
                    ANSI SQL does not support a boolean column type. Hrorm will convert between Java's boolean
                    enumeration of true/false with the strings "T" and "F" in the database.
                </p>

                <pre>
    daoBuilder.withBooleanColumn("IS_HIGH_SCHOOL_GRADUATE", Person::isHighSchoolGraduate, Person::setHighSchoolGraduate);</pre>

                <p>For the enumerated <code>HairColor</code> type, hrorm needs a bit more help, via an implementation
                of its <code>Converter</code> interface. We need a simple class that looks like this:</p>

                <pre>
    class HairColorConverter implements Converter&lt;HairColor, String&gt; {
        @Override
        public String from(HairColor item) {
            return item.getColorName();
        }

        @Override
        public HairColor to(String s) {
            return HairColor.forColorName(s);
        }
    }</pre>

                <p>Once the <code>Converter</code> exists, we can teach the <code>DaoBuilder</code> about it
                and the hair color field.</p>

                <pre>
    daoBuilder.withConvertingStringColumn("HAIR_COLOR", Person::getHairColor, Person::setHairColor, new HairColorConverter());</pre>

                <p>Notice that in addition to the usual fields for column name, getter, and setter, we additionally
                must specify the conversion mechanism.</p>

                <p>That completes the <code>DaoBuilder</code>. Now we can actually build a <code>Dao&lt;Person&gt;</code>
                    object, assuming we have a <code>java.sql.Connection</code>.</p>

                <p>But before that, we should note that the <code>DaoBuilder</code> supports a fluent interface,
                so we could write all of the above as:</p>

                <pre>
    DaoBuilder&lt;Person&gt; daoBuilder = new DaoBuilder<>("PERSON_TABLE", Person::new)
                .withPrimaryKey("ID","PERSON_SEQUENCE", Person::getId, Person::setId)
                .withStringColumn("NAME", Person::getName, Person::setName)
                .withIntegerColumn("WEIGHT", Person::getWeight, Person::setWeight)
                .withBigDecimalColumn("HEIGHT", Person::getHeight, Person::setHeight)
                .withLocalDateTimeColumn("BIRTHDAY", Person::getBirthday, Person::setBirthday)
                .withBooleanColumn("IS_HIGH_SCHOOL_GRADUATE", Person::isHighSchoolGraduate, Person::setHighSchoolGraduate)
                .withConvertingStringColumn("HAIR_COLOR", Person::getHairColor, Person::setHairColor, new HairColorConverter());</pre>

                <p>In just 8 lines of code, we have taught hrorm everything it needs to know to CRUD <code>Person</code>
                objects.</p>
            </div>

            <a name="sibling_relations"></a>
            <div class="card fluid">
                <h3>Sibling Relations</h3>
                <hr>

                <p>When one entity object contains a reference to another entity object, hrorm calls that a
                sibling or join relationship.</p>

                <p>Consider a model of cities and states, where each city contains a reference to a state.</p>

                <pre>
    class State {
        Long id;
        String name;
    }

    class City {
        Long id;
        String name;
        State state;
    }</pre>

                <p>This could be backed by this schema.</p>

                <pre>
    CREATE TABLE STATE (
        ID INTEGER PRIMARY KEY,
        NAME TEXT,
    );

    CREATE TABLE CITY (
        ID INTEGER PRIMARY KEY,
        NAME TEXT,
        STATE_ID INTEGER
    );

    CREATE SEQUENCE STATE_SEQUENCE;
    CREATE SEQUENCE CITY_SEQUENCE;</pre>

            <p>Creating the <code>State</code> <code>DaoBuilder</code> is trivial.</p>

            <pre>
    DaoBuilder&lt;State&gt; stateDaoBuilder = new DaoBuilder&lt;&gt;("STATE", State::new)
            .withPrimaryKey("ID", "STATE_SEQUENCE", State::getId, State::setId)
            .withStringColumn("NAME", State::getName, State::setName);</pre>

            <p>There is one new trick to creating the <code>City</code> <code>DaoBuilder</code>: using the
            <code>DaoBuilder.joinColumn()</code> method which will refer to the <code>stateDaoBuilder</code>
            we just defined.</p>

            <pre>
     DaoBuilder&lt;City&gt; cityDaoBuilder = new DaoBuilder&lt;&gt;("CITY", City::new)
            .withPrimaryKey("ID", "CITY_SEQUENCE", City::getId, City::setId)
            .withStringColumn("NAME", City::getName, City::setName)
            .withJoinColumn("STATE_ID", City::getState, City::setState, stateDaoBuilder);</pre>

            <p>The <code>withJoinColumn</code> method accepts an extra parameter: a <code>DaoDescriptor</code>.
            Both <code>DaoBuilder</code> and the <code>Dao</code> class implement this interface. Generally,
            it's much more convenient to create all the builder objects together.</p>

            <p><b>Sibling or join relationships in hrorm are one-way.</b> One object declares that it has a reference
            to another. Trying to make a circular relationship will lead to errors.</p>

            <p>When hrorm instantiates objects like <code>City</code> from the database, it automatically
            instantiates the appropriate sibling <code>State</code> objects and sets the field in the
            <code>City</code> object.</p>

            <p>Of course, you could just treat these as two one-table <code>Dao</code> objects, and then
            right some code to glue things together. In addition to being inconvenient, this will likely
            have poorer performance, since hrorm will issue a SQL left join to load the <code>City</code>
            and <code>State</code> objects with one query.</p>

            <p>Objects can have several join columns, and those objects can have their own join columns.
            Hrorm will attempt to transitively load the entire object graph when a <code>select()</code> method is called
            on the <code>Dao</code>. There is a limit to how many joins hrorm can perform. Additionally, there
                is a limit to how many joins a database engine will allow. Consider this when designing <code>Dao</code>
                objects.
                Also remember, sibling relationships are for reading and populating objects,
            not for making saves or updates. If a sibling object is mutated, it must be saved itself.</p>

            </div>

            <a name="parent_child_relations"></a>
            <div class="card fluid">
                <h3>Parent Child Relations</h3>
                <hr>

                <p>When one entity contains a collection of other entities, hrorm calls that a parent child relation.</p>

                <p>Here is a simple model for tracking inventories of stocks of things through time. At each instant
                that we measure, we want to know what quantity of each product we have.</p>

                <pre>
    public class Inventory {
        Long id;
        LocalDateTime date;
        List&lt;Stock&gt; stocks;
    }

    public class Stock {
        Long id;
        String productName;
        BigDecimal amount;
    }</pre>

                <p>The <code>Inventory</code> class represents a snapshot in time of what was available in inventory,
                modeled as a <code>List</code> of <code>Stock</code> items, each of which contains a product name
                and a decimal quantity of how much of that thing is available. Notice that the <code>Stock</code> model
                includes a reference to the inventory ID, but not the inventory object itself.</p>

                <p>To model this in the database, we make each item in the <code>STOCK</code> table point back to
                an <code>INVENTORY</code> record, as follows.</p>

                <pre>
    CREATE TABLE INVENTORY (
        ID INTEGER PRIMARY KEY,
        DATE TIMESTAMP
    );

    CREATE TABLE STOCK (
        ID INTEGER PRIMARY KEY,
        INVENTORY_ID INTEGER,
        PRODUCT_NAME TEXT,
        AMOUNT DECIMAL
    );

    CREATE SEQUENCE INVENTORY_SEQUENCE;
    CREATE SEQUENCE STOCK_SEQUENCE;</pre>

                <p>To model this in hrorm, we need to teach it about the parent-child relationship between the two entities
                    using the <code>DaoBuilder.withParentColumn()</code> and <code>DaoBuilder.withChildren()</code> methods.
                    First we make a Dao for the <code>Stock</code> entity.</p>

                <pre>
    DaoBuilder&lt;Stock&gt; stockDaoBuilder = new DaoBuilder&lt;&gt;("STOCK", Stock::new)
            .withPrimaryKey("ID","STOCK_SEQUENCE", Stock::getId, Stock::setId)
            .withParentColumn("INVENTORY_ID")
            .withStringColumn("PRODUCT_NAME", Stock::getProductName, Stock::setProductName)
            .withBigDecimalColumn("AMOUNT", Stock::getAmount, Stock::setAmount);</pre>

                <p>The column <code>INVENTORY_ID</code> is marked not as an integer column,
                    but with the special <code>withParentColumn</code> method.
                    An entity can have only one parent. In the <code>Inventory</code>
                    <code>DaoBuilder</code> we use the <code>withChildren</code> method
                    to complete the relationship definition..</p>

                <pre>
    DaoBuilder&lt;Inventory&gt; inventoryDaoBuilder = new DaoBuilder&lt;&gt;("INVENTORY", Inventory::new)
            .withPrimaryKey("ID", "INVENTORY_SEQUENCE", Inventory::getId, Inventory::setId)
            .withLocalDateTimeColumn("DATE", Inventory::getDate, Inventory::setDate)
            .withChildren(Inventory::getStocks, Inventory::setStocks, stockDaoBuilder);</pre>

                <p>When we create a <code>Dao</code> in this fashion we create a category of entity, the child,
                that is wholly dependent upon another, the parent. Whenever we insert, update, delete, or
                select the parent entity, the changes we make flow through the children and transitively
                to their children.</p>

                <p>Be careful, if you do not want the children to be deleted, this is not the relationship
                you want to build. In particular, remember that issuing an <code>update</code>
                will result not just in a SQL <code>UPDATE</code> in the database, but possibly
                a whole series of <CODE>INSERT</CODE>, <code>UPDATE</code>, and <code>DELETE</code>
                queries being run.</p>

                <p>Hrorm always understands child objects to be members of type <code>List</code>.
                No other collection type is supported.</p>

                <h5>Back-References</h5>

                <p>If your object model for includes a back-reference from the child to the parent,
                Hrorm will populate it for you. If in the model above, the <code>Stock</code>
                    class had a reference to its parent <code>Inventory</code> we could use an
                    overloaded <code>withParentColumn()</code> method call on its <code>DaoBuilder</code>
                    as follows:</p>

                <pre>
    .withParentColumn("INVENTORY_ID", Stock::getInventory, Stock::setInventory)</pre>

                <p>That will cause the reference to the parent object to be automatically
                set when using any of the <code>Dao</code> <code>select</code> methods.</p>

            </div>

            <div class="card fluid">

                <a name="immutable_models"></a>
                <h3>Immutable Models</h3>

                <hr>

                <p>If you prefer that your Java entity model be made up of immutable classes, hrorm can support that.</p>

                <p>Hrorm works well with immutable objects that have distinct builder classes for managing their setters.
                    To allow this, hrorm provides an <a href="/javadocs/latest/org/hrorm/IndirectDaoBuilder.html"><code>IndirectDaoBuilder</code></a>
                    class. The indirect moniker is intended to suggest that the entities will not be directly constructed,
                    but that will be handled by the builder objects.</p>

                <p>The following example uses lombok style builders, but you can roll your own if that's what you prefer.</p>

                <pre>
    @lombok.Builder
    @lombok.Data
    public class ImmutableThing {
        private final Long id;
        private final String word;
        private final BigDecimal amount;
    }

    IndirectDaoBuilder&lt;ImmutableThing, ImmutableThing.ImmutableThingBuilder&gt; immutableThingDaoBuilder =
            new IndirectDaoBuilder&lt;&gt;("immutable_thing", ImmutableThing::builder, ImmutableThing.ImmutableThingBuilder::build)
            .withPrimaryKey("id", "immutable_thing_seq", ImmutableThing::getId, ImmutableThing.ImmutableThingBuilder::id)
            .withBigDecimalColumn("amount", ImmutableThing::getAmount, ImmutableThing.ImmutableThingBuilder::amount)
            .withStringColumn("word", ImmutableThing::getWord, ImmutableThing.ImmutableThingBuilder::word);

    Connection connection = // comes from somewhere

    // this retured object implements the identical interface as any other hrorm Dao
    Dao&lt;ImmutableThing&gt; immutableThingDao = immutableThingDaoBuilder.buildDao(connection);</pre>

                <p>It works very similarly to the regular <code>DaoBuilder</code>, but some extra details
                    are required. There are now two type parameters: one for the entity itself and
                    one for its builder object. On construction, instead of simply showing how to create
                    a new entity instance, two parameters show how to make a new builder instance and
                    how to make a new entity instance from the builder. Finally, all the setters are
                    specified on the builder class, not the entity instance.</p>

                <p>With a regular <code>Dao</code> the object's primary key will be set on
                    the object during the <code>insert()</code>. This is not true for <code>Dao</code>
                    objects created from an <code>IndirectDaoBuilder</code>. The <code>insert</code>
                    method will still return the newly issued ID.</p>

                <p>Indirect Dao objects support all the mechanisms for child and sibling records
                    that regular Dao objects do. Due to the lack of population of IDs, some care
                    must be taken. You cannot simply insert a sibling object and then
                    immediately place it into a new entity instance, since it will not yet
                    have its ID set.</p>

            </div>


            <a name="constraints"></a>
            <div class="card fluid">
                <h3>Constraints</h3>
                <hr>

                <p>Hrorm provides little support for placing constraints on your object models or
                    schema. The correct place for that is within your object model or schema or, best
                    of all, both.</p>

                <p>The <code>DaoBuilder</code> does allow you to mark particular columns as not null,
                by calling the <code>notNull</code> method. It will apply that constraint to the
                last column added to the growing definition.</p>

                <p>Where a not null condition is defined in hrorm, it will prevent the creation
                of null entries in the particular field in question, either through inserts
                or updates. However, hrorm will ignore the constraint when attempting load
                records from the database, on the theory that loading questionable data is
                better than not loading it.</p>

                <p>Since a properly designed object model and database schema can easily replicate
                this functionality and provide other much more significant invariant enforcement,
                it must be admitted that this facility is of little practical use.</p>

                <p>One case where this can be helpful is during periods of data migration. If some
                element is moving from optional to required, Hrorm can at least help creating new
                records without the newly required element, until such time as more robust
                enforcement of constraints can be implemented by the application and database.</p>

            </div>

            <a name="validation"></a>
            <div class="card fluid">
                <h3>Validation</h3>
                <hr>

                <p>Hrorm provides a <a href="/javadocs/latest/org/hrorm/Validator.html"><code>Validator</code></a> to
                    help in sure the database schema is in sync with the code.</p>

                <p>The validation provided is not a substitute for testing that code works as intended. It simply
                checks that the names of the tables, columns, and sequences provided in the <code>Dao</code>
                descriptions exist as stated. As such, it can quickly find typos or other simple errors and
                report them. This can be particularly useful in times of database refactoring.</p>

                <p>To check that a particular <code>Dao</code> is correct, simply pass it, or its builder,
                to the <code>Validator::validate</code> method with a live <code>Connection</code>.
                If the validation fails, an exception will be raised whose message describes the problems
                found.</p>

                <pre>
    DaoBuilder&lt;Entity&gt; daoBuilder = new DaoBuilder&lt;&gt;("TABLE", Entity::new)
            .withPrimaryKey("id", "SEQUENCE", Entity::getId, Entity::setId)
            .withStringColumn("STRING_COL", Entity::getStringThing, Entity::setStringThing)
            .withIntegerColumn("INT_COL", Entity::getIntegerThing, Entity::setIntegerThing);

    Connection connection = // create connection just as for your application

    try {
        Validator.validate(connection, daoBuilder);
    } catch (HrormException ex){
        System.out.println(ex.getMessage);
    }</pre>

                <p>The testing that this performs is light. It will <b>not</b> attempt to make any changes to the
                state of the database. It will merely check to make sure the structures exist as expected.
                Moreover, each <code>Dao</code> is tested individually. Related <code>Dao</code>
                objects, even dependent child objects, are not checked by the <code>Validator</code>.</p>

            </div>


            <a name="daos"></a>
            <h2>Daos</h2>

            <p>To create a <code>Dao</code> from a <code>DaoBuilder</code>, just pass it a <code>java.sql.Connection</code>:</p>

            <pre>
    // Assume the existence of some ConnectionPool
    Connection connection = ConnectionPool.connect();
    Dao&lt;Person&gt; dao = daoBuilder.buildDao(connection);</pre>

            <a name="insert"></a>
            <div class="card fluid">
            <h3>Insert</h3>
                <hr>

                <p>To create a new record in the database, we create a new instance of the class and pass it
                    to <code>Dao.insert()</code>.</p>

                <pre>
    Person person = new Person();
    // set values for the fields we want
    person.setName("Thomas Bartholomew Atkinson Wilberforce");
    person.setHighSchoolGraduate(true);
    person.setWeight(100L);
    long id = dao.insert(person);
    connection.commit();</pre>

                <p>After that code runs, the record will be stored in the database. Hrorm will have pulled
                a new sequence value and set it on the object. The following assertions will be true. Note that for immutable objects whose <code>Dao</code> implementations were created using an <code>IndirectDaoBuilder</code> the ID will not be set.</p>

                <pre>
    Assert.assertNotNull(person.getId());
    Assert.assertTrue(id == person.getId());</pre>

                <h5>Children</h5>

                <p>Hrorm will automatically insert child records of the instance being saved, if any.</p>

                <h5>Siblings</h5>

                <p>If the record has sibling entities, references to those will be persisted. But be careful,
                those sibling references must be persisted first. Sibling inserts and updates do not cascade.</p>

            </div>

            <a name="select"></a>
            <div class="card fluid">
                <h3>Select</h3>
                <hr>

                <p>Hrorm provides a few methods for reading data out of the database and instantiating entity
                objects.</p>

                <p>All of the selection mechanisms below will fully read and populate the entire relevant object graph
                including all children and siblings and all their transitive references.</p>

                <h5>Primary Key</h5>

                <p>You can read an item from the database if you know its primary key.</p>

                <pre>
    Person person = dao.select(432L);</pre>

                <p>If you want to read several IDs at once, you can.</p>

                <pre>
    List&lt;Person&gt; personList = dao.selectMany(Arrays.asList(432L,21L,7659L));</pre>

                <h5>All Records</h5>

                <p>If you want all the records (presumably for a smallish table) just do</p>

                <pre>
    List&lt;Person&gt; personList = dao.selectAll();</pre>

                <h5>By Columns</h5>

                <p>Most of the time, you do not know up front what ID or IDs you are intersted in, so
                hrorm allows you to select by columns. To do this, we make an instance of the entity
                we are searching for and populate it with the values we want to match. Suppose we want
                to find all the people who are high school graduates that weigh 100 kilograms. Here's what
                we can do.</p>

                <pre>
    Person personTemplate = new Person();
    personTemplate.setHighSchoolGraduate(true);
    personTemplate.setWeight(100L);

    List&lt;Person&gt; people = personDao.selectManyByColumns(personTemplate, "IS_HIGH_SCHOOL_GRADUATE", "WEIGHT");</pre>

                <p>Notice that hrorm wants the names of the database <b>columns</b>, not the fields on the object.</p>

                <p>If we know that a particular query will only return 0 or 1 results (for instance, if there is
                a uniqueness constraint on the name field), hrorm provides a convenience method for that.</p>

                <pre>
    Person personTemplate = new Person();
    personTemplate.setName("Rumplestiltskin");

    Person person = personDao.selectByColumns(personTemplate, "NAME");</pre>

                <p>If you use this method and hrorm finds more than one record, it will raise an exception.</p>

                <p>At the moment, hrorm only supports exact matches, not any <code>LIKE</code> syntax.</p>

            </div>

            <a name="update"></a>
            <div class="card fluid">
                <h3>Update</h3>
                <hr>

                    <p>After making changes to the state of the object, we can call</p>

                <pre>
    dao.update(person);
    connection.commit();</pre>

                <p>This will issue an update in the database based on the primary key (<code>id</code>) field.</p>

                <p>Updates will automatically propagate to children, but not to siblings.</p>

            </div>

            <a name="delete"></a>
            <div class="card fluid">
                <h3>Delete</h3>
                <hr>

                <p>When we are done with a person, we can issue</p>

                <pre>
    dao.delete(person);
    connection.commit();</pre>

                <p>To remove the record from the database, using the primary key, as with an update.</p>

                <p>Deletes will automatically propagate to children, but not to siblings.</p>

            </div>

            <a name="atomic"></a>
            <div class="card fluid">
                <h3>Atomic</h3>

                <p>In addition to the <code>insert</code>, <code>update</code>, and <code>delete</code>
                methods, hrorm <code>Dao</code> objects provide variants of those methods
                called <code>atomicInsert</code>, <code>atomicUpdate</code>, and <code>atomicDelete</code>.
                These are useful if you do not mind your changes being committed automatically. But they
                cannot be used inside larger transactions. Additionally, these methods will close the
                <code>Connection</code> object their enclosing <code>Dao</code> was built with.</p>

            </div>


            <a name="sql"></a>
            <div class="card fluid">
                <h3>SQL</h3>

                <p>The <code>SQL</code> that hrorm generates to make a <code>Dao</code> can be accessed by
                calling the <code>queries()</code> method. The <code>SQL</code> is formatted
                in a way suitable for passing to a <code>PreparedStatement</code> with embedded
                question marks for variable substitution.</p>

                <p>You can also access a <code>Queries</code> object by calling <code>buildQueries()</code>
                on a <code>DaoBuilder</code> object. This provides an identical instance, but does not
                require a <code>Connection</code>, which building a <code>Dao</code> does.</p>

            </div>


            <a name="miscellaneous"></a>
            <h2>Miscellaneous</h2>
            <hr>

            <div class="card fluid">

                <a name="exceptions"></a>
                <h3>Exceptions</h3>

                <hr>

                <p>Hrorm thinks that checked exceptions are a mistake. In an application with a database dependency,
                    you have three choices:</p>

                <ol>
                    <li>Have <code>SQLException</code> declared in most methods all over your application.</li>
                    <li>Try to handle <code>SQLException</code> somehow when doing interactions with
                        <code>Connection</code>,
                        <code>Statement</code>, and <code>ResultSet</code> objects, defeating the purpose of
                        exception handling being centralized and removed from normal application flow.
                    </li>
                    <li>Convert <code>SQLException</code> to some other type, descended from
                        <code>RuntimeException</code>.
                    </li>
                </ol>

                <p>
                    Hrorm opts for method 3.
                </p>

                <p>Hrorm will throw a <code>HrormException</code> when it has a problem. If there was an underlying
                    <code>SQLException</code> that will be exposed on the <code>HrormException</code>.
                </p>

            </div>


            <div class="card fluid">

                <a name="logging"></a>
                <h3>Logging</h3>

                <hr>

                <p>The state of Java logging is a tiny bit unfortunate.</p>

                <p>The <code>java.util.logging</code> package in the standard library is not widely
                    used. Unfortunately, rather than a set of pluggable interfaces, they provided a concrete
                    implementation.</p>

                <p>Log4j is pretty ubiquitous, but not universal. Additionally, hrorm currently has
                    no dependencies. It would be a shame to add one.</p>

                <p>Hrorm therefore uses <code>java.util.logging</code> implementation.
                    There are ways to redirect that to log4j and other logging frameworks.</p>

                <p>Hrorm logs to a logger named "org.hrorm" all the SQL it issues at INFO level.</p>

            </div>

            <div class="card fluid">

                <a name="visibility"></a>
                <h3>Visibility</h3>

                <hr>

                <p>Hrorm is designed to have a small surface area for clients. Most of the time, clients should only
                    need to interact with three hrorm types: <code>DaoBuilder</code>, <code>Dao</code>, and
                    <code>HrormException</code>. Clients might also be expected to create a few instances of
                    <code>Converter</code> objects and perhaps to use a <code>Transactor</code>. After that,
                    there is nothing in Hrorm that is designed to be used in client code.</p>

                <p>In spite of this, almost all the classes in hrorm are public and contain public constructors
                    and methods. If you feel like instantiating a <code>StringColumn</code> object, hrorm feels
                    no need to try to stop you.</p>

                <p>Most of the time, hrorm will point out in the Javadocs where classes are not
                    intended for clients to use directly.</p>

            </div>

        </div>

    </div>
</div>

</body>
</html>
