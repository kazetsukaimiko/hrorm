<!DOCTYPE html>
<html>
<head>
    <title>hrorm - Documentation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mini.css/3.0.0/mini-default.min.css">
    <link rel="stylesheet" href="/css/hrorm.css">
</head>
<body>


<div class="container">
    <div class="row">

        <div class="col-sm-3">
            <nav id="navigation">
                <a href="#one_table">One Table</a>
            </nav>
        </div>

        <div class="col-sm-9">
            <a name="one_table"></a>
            <div class="card fluid">
                <h2>One Table</h2>
                <hr>
                <p>The easiest case for any ORM tool is persisting a single object backed by a single table.
                Let's work on persisting a model for a person that includes the following elements:</p>
                <ul>
                    <li>Name (a string or text)</li>
                    <li>Birthday (a date)</li>
                    <li>Weight in kilograms (an integer)</li>
                    <li>Height in meters (a decimal)</li>
                    <li>High school graduate? (a boolean)</li>
                    <li>Hair color (an enumerated type)</li>
                </ul>

                <p>To model the person entity, we write a Java Person object.</p>

                <pre>
    class Person {
        Long id;
        String name;
        long weight;
        BigDecimal height;
        LocalDateTime birthday;
        boolean isHighSchoolGraduate;
        HairColor hairColor;
    }</pre>

                <p>A few small points.</p>

                <ul>
                    <li>Use your imagination to fill in getters, setters, equals, hashCode, etc.</li>
                    <li>We have one extra field that we did not have in our logical model: an id field that is to be used
                        for persistence.</li>
                    <li>Assume that their is an enumerated type for hairColor, HairColor.Black, HairColor.Brown, etc.</li>
                </ul>

                <p>In the database we will create two structures for persisting this class: a table to store the data
                and a sequence to issue the IDs.</p>

                <pre>
    CREATE SEQUENCE PERSON_SEQUENCE;

    CREATE TABLE PERSON_TABLE (
        ID INTEGER PRIMARY KEY,
        NAME TEXT,
        WEIGHT INTEGER,
        WEIGHT DECIMAL,
        BIRTHDAY TIMESTAMP,
        IS_HIGH_SCHOOL_GRADUATE TEXT,
        HAIR_COLOR TEXT
    );</pre>

                <p>To translate between the database reprentation and the Java representation, we plan to use
                a <code>Dao</code> object. We could construct that directly, but hrorm provides a DaoBuilder
                class that makes things much easier. In hrorm, both <code>Dao</code> objects and their builders
                are parameterized on the type of thing they persist. We start off by simply calling the
                <code>DaoBuilder</code> constructor.</p>

                <pre>
    DaoBuilder&lt;Person&gt; daoBuilder = new DaoBuilder&lt;&gt;("PERSON_TABLE", Person::new);</pre>

                <p>The constructor takes two arguments: the name of the table and a no-argument method for
                creating a new instance of the parameterized type.</p>

                <p>Next, we need to define the primary key for this entity.</p>

                <pre>
    daoBuilder.withPrimaryKey("ID","PERSON_SEQUENCE", Person::getId, Person::setId);</pre>

                <p>The primary key is defined with four elements:</p>

                <ol>
                    <li>The name of the primary key column in the table ("ID")</li>
                    <li>The name of the sequence that populates the primary keys ("PERSON_SEQUENCE")</li>
                    <li>A function that retrieves the primary key (of type <code>Long</code>) from the <code>Person</code> object.</li>
                    <li>A function that can set the primary key onto the object.</li>
                </ol>

                <p>With that covered, we can being to teach the <code>DaoBuilder</code> about the individual data
                elements. First, we will teach it about the name field.</p>

                <pre>
    daoBuilder.withStringColumn("NAME", Person::getName, Person::setName);</pre>

                <p>This explains that that table has a column named "NAME" and that the value in the table can
                be populated from calling <code>getName()</code> on a <code>Person</code>, and that value
                can be set by calling <code>setName()</code>. There are other methods on the <code>DaoBuilder</code>
                for other Java types.</p>

                <p>For the integer weight value (which should actually be a <code>Long</code> or <code>long</code>,
                not an <code>int</code> or <code>short</code>.</p>

                <pre>
    daoBuilder.withIntegerColumn("WEIGHT", Person::getWeight, Person::setWeight);</pre>

                <p>For decimal values, hrorm supports the <code>java.math.BigDecimal</code> type.</p>

                <pre>
    daoBuilder.withBigDecimalColumn("HEIGHT", Person::getHeight, Person::setHeight);</pre>

                <p>For dates and times, hrorm supports the <code>java.time.LocalDateTime</code> type.</p>

<pre>
    daoBuilder.withLocalDateTimeColumn("BIRTHDAY", Person::getBirthday, Person::setBirthday);</pre>

                <p>And similarly for boolean values. Note that the table should declare a text or string value.
                    Not all databases support a boolean column type. Hrorm will convert between Java's boolean
                    enumeration of true/false with the strings "T" and "F" in the database.
                </p>

                <pre>
    daoBuilder.withBooleanColumn("IS_HIGH_SCHOOL_GRADUATE", Person::isHighSchoolGraduate, Person::setHighSchoolGraduate);</pre>

                <p>For the enumerate <code>HairColor</code> type, hrorm needs a bit more help, via an implementation
                of its <code>Converter</code> interface. We need a simple class that looks like this:</p>

                <pre>
    class HairColorConverter implements Converter&lt;HairColor, String&gt; {
        @Override
        public String from(HairColor item) {
            return item.getColorName();
        }

        @Override
        public HairColor to(String s) {
            return HairColor.forColorName(s);
        }
    }</pre>

                <p>Once the <code>Converter</code> exists, we can teach the <code>DaoBuilder</code> about it
                and the hair color field.</p>

                <pre>
    daoBuilder.withConvertingStringColumn("HAIR_COLOR", Person::getHairColor, Person::setHairColor, new HairColorConverter());</pre>

                <p>Notice that in addition to the usual fields for column name, getter, and setter, we additionally
                must specify the conversion mechanism.</p>

                <p>That completes the <code>DaoBuilder</code>. Now we can actually build a <code>Dao&lt;Person&gt;</code>
                    object, assuming we have a <code>java.sql.Connection</code>.</p>

                <p>But before that, we should note that the <code>DaoBuilder</code> supports a fluent interface,
                so we could write all of the above as:</p>

                <pre>
    DaoBuilder&lt;Person&gt; daoBuilder = new DaoBuilder<>("PERSON_TABLE", Person::new)
                .withPrimaryKey("ID","PERSON_SEQUENCE", Person::getId, Person::setId)
                .withStringColumn("NAME", Person::getName, Person::setName)
                .withIntegerColumn("WEIGHT", Person::getWeight, Person::setWeight)
                .withBigDecimalColumn("HEIGHT", Person::getHeight, Person::setHeight)
                .withLocalDateTimeColumn("BIRTHDAY", Person::getBirthday, Person::setBirthday)
                .withBooleanColumn("IS_HIGH_SCHOOL_GRADUATE", Person::isHighSchoolGraduate, Person::setHighSchoolGraduate)
                .withConvertingStringColumn("HAIR_COLOR", Person::getHairColor, Person::setHairColor, new HairColorConverter());</pre>

                <p>In just 8 lines of code, we have taught hrorm everything it needs to know to CRUD <code>Person</code>
                objects.</p>

                <p>To get a <code>Dao</code> from a <code>DaoBuilder</code>, just pass it a connection:</p>

                <pre>
    Dao&lt;Person&gt; dao = daoBuilder.buildDao(connection);</pre>

                <p>The first thing to do is insert a new record into the database.</p>

                <pre>
    Person person = new Person();
    // set values on the fields but leave the ID null
    long id = dao.insert(person);
    connection.commit();</pre>

                <p>After that code runs, the record will be stored in the database. Hrorm will have pulled
                a new sequence value and set it on the object. The following assertions will be true.</p>

                <pre>
    Assert.assertNotNull(person.getId());
    Assert.assertTrue(id == person.getId());</pre>

                <p>After making changes to the state of the object, we can call</p>

                <pre>
    dao.update(person);
    connection.commit();</pre>

                <p>This will issue an update in the database based on the primary key (<code>id</code>) field.</p>

                <p>When we are done with this person, we can issue</p>

                <pre>
    dao.delete(person);
    connection.commit();</pre>

                <p>To remove the record from the database, using the primary key, as with an update.</p>


            </div>


        </div>
    </div>
</div>

</body>
</html>