<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Chapter 2</title>
</head>

<body>

<p>
    Prior articles about <a href="https://hrorm.org">Hrorm</a> gave
    <a href="https://dzone.com/articles/introducing-hrorm-a-simple-declarative-type-checke">an introduction</a>
    and a <a href="">first lesson</a>.
    You may wish to take a look at those if you haven't before diving into this article, which will explain
    how Hrorm, a small, simple ORM tool for Java, handles relationships between entities.
</p>

<h4>On Relations</h4>

<p>
    SQL RDBMS platforms remain somewhat unfashionable. Some people seem to believe in a myth that they
    are not scalable enough. This may be true for some very large data sets and applications,
    but unless you work for a company with a name like Google or Amazon, your data is probably
    easily manageable by any number of databases.
</p>

<p>
    There is also a tendency to imagine that a storage solution with an explicit schema will
    slow down development efforts. Many people have pointed out that you always have a schema
    (possibly more than one) even if you have not used tools that make it explicit. In my
    personal experience, knowing and understanding more about the systems I work on does
    not slow me down.
</p>

<p>
    But neither of those two things is a critical issue to me. The flaw with no-SQL, document
    stores to me is how they manage relations. If you have data describing actors and tv shows,
    a document just will not cover it. If you choose to make the tv shows your top level structure,
    you will have to repeat the data about actors, since actors can appear in more than one
    show. If you choose to make actors your top level, you have to repeat the data about shows,
    since shows have more than one actor. Normalization is the process of figuring out what
    your entities are, and how they relate to each other.
</p>

<p>
    I know that document stores have references from one document to another, but RDBMS's have
    been managing data according to a well-thought out mathematical theory for decades. To ignore
    them feels like a step backwards to me.
</p>

<p>
    It's the job of ORM tools like Hrorm to make the annoyances of using an RDBMS as near to
    as easy as using the filesystem as possible. Developers should get power and security, and they
    should not have to pay with inconvenience and aggravation. Whether or not Hrorm succeeds,
    well, that's up to you to judge.
</p>

<h4>Siblings</h4>

<p>
    One of the simplest relations two entities can have is when one always accompanies another.
    In the United States, every city is in a state. In Java, we might model cities and states
    like this. (The examples omit getters, setters, equals, and other Java essentials.)
</p>

<pre>
public class State {
    Long id;
    String name;
}

public class City {
    Long id;
    String name;
    State state;
}</pre>

<p>
    The corresponding tables that would back this model would look almost identical.
</p>

<pre>
CREATE TABLE STATE (
    ID INTEGER PRIMARY KEY,
    NAME TEXT
);

CREATE TABLE CITY (
    ID INTEGER PRIMARY KEY,
    NAME TEXT,
    STATE_ID INTEGER
);</pre>

<p>
    The biggest difference is that in the object model, we include a reference to the
    state itself, in the database, the CITY only directly refers to the STATE's primary
    key. Hrorm works by defining the relationship between the RDBMS SQL world and the
    Java world by creating <code>DaoBuilder</code> objects. The Hrorm to
    describe these entities looks like this:
</p>

<pre>
DaoBuilder&lt;State&gt; StateDaoBuilder = new DaoBuilder<>("STATE", State::new)
        .withPrimaryKey("ID", "STATE_SEQUENCE", State::getId, State::setId)
        .withStringColumn("NAME", State::getName, State::setName);

DaoBuilder&lt;City&gt; CityDaoBuilder = new DaoBuilder<>("CITY", City::new)
        .withPrimaryKey("ID", "CITY_SEQUENCE", City::getId, City::setId)
        .withStringColumn("NAME", City::getName, City::setName)
        .withJoinColumn("STATE_ID", City::getState, City::setState, StateDaoBuilder);</pre>

<p>
    Most of that is identical to the features of Hrorm described in the previous articles.
    The only new thing is the call to the method <code>withJoinColumn</code>. That method
    accepts not just the column name and the accessors of the field but also a reference
    to the <code>DaoBuilder</code> (technically, the <code>DaoDescriptor</code> an interface
    Hrorm uses and that <code>DaoBuilder</code> implements) of the joined entity.
</p>

<p>
    Now when we perform a select of a city from the database through Hrorm, it will not
    just read the <code>CITY</code> table, it will create a query that looks like this:
</p>

<pre>SELECT A.ID, A.NAME, B.ID, B.NAME
    FROM CITY A
    LEFT JOIN STATE B ON A.STATE_ID = B.ID</pre>

<p>
    After issuing that query, Hrorm will automatically populate a <code>State</code>
    object, and set it on the <code>City</code> object. Similarly, when wither the
    <code>Dao.insert()</code> or <code>Dao.update</code>> method is invoked,
    Hrorm will make sure that the correct reference is persisted. But,
    <code>Dao.delete()</code> will act only on the entity itself, it will not
    cascade to the joined entity.
</p>

<h4>Parent-Child</h4>

<p>
    A join relationship only works when one object contains a reference to
    one other object. What about something like a recipe, that has many ingredients?
</p>

<pre>
class Recipe {
    Long id;
    String name;
    List&lt;Ingredient&gt; ingredients;
}

class Ingredient {
    Long id;
    Recipe recipe;
    String name;
    long amount;
}</pre>

<p>
    Note that the <code>Ingredient</code> has a reference to its owning <code>Recipe</code>.
    This is sometimes useful, and sometimes not. Hrorm supports object models with or without
    back-references like this.
</p>

<p>
    That might be backed by two tables like this.
</p>

<pre>
CREATE TABLE RECIPES (
    ID INTEGER PRIMARY KEY,
    NAME TEXT
);

CREATE TABLE INGREDIENTS (
    ID INTEGER PRIMARY KEY,
    RECIPE_ID INTEGER,
    NAME TEXT,
    AMOUNT INTEGER
);</pre>

<p>
    These models have more significant differences than the cities and states.
    It's not just that the database description deals with keys rather than
    the entities themselves, the responsibility for managing the relationship
    has been reversed. In object model land, the <code>Hand</code> has a list
    of <code>Fingers</code>. In the database, the <code>FINGER</code> table contains a
    column with a foreign key point to the <code>HAND</code>.
</p>

<p>
    To manage this relationship with Hrorm, we need to make special note in both
    the recipe and ingredient <code>DaoBuilder</code> objects. Let's start with the
    ingredient.
</p>

<pre>
DaoBuilder&lt;Ingredient&gt; ingredientDaoBuilder = new DaoBuilder<>("INGREDIENT", Ingredient::new)
        .withPrimaryKey("ID", "INGREDIENT_SEQUENCE", Ingredient::getId, Ingredient::setId)
        .withParentColumn("RECIPE_ID", Ingredient::getRecipe, Ingredient::setRecipe)
        .withStringColumn("NAME", Ingredient::getName, Ingredient::setName)
        .withIntegerColumn("AMOUNT", Ingredient::getAmount, Ingredient::setAmount);</pre>

<p>
    Like the join example, we see that there is a special column defined: a parent column.
    This alerts Hrorm that the column should be linked to another entity. The <code>Recipe</code>
    <code>DaoBuilder</code> looks like this.
</p>

<pre>
DaoBuilder&lt;Recipe&gt; recipeDaoBuilder = new DaoBuilder<>("RECIPE", Recipe::new)
            .withPrimaryKey("ID", "RECIPE_SEQUENCE", Recipe::getId, Recipe::setId)
            .withStringColumn("NAME", Recipe::getName, Recipe::setName)
            .withChildren( Recipe::getIngredients, Recipe::setIngredients, ingredientDaoBuilder);</pre>

<p>
    In addition to the column definitions, there is an extra <code>withChildren()</code> call
    that does not correspond to any column. In addition to the accessors it contains a reference
    to the <code>Ingredient</code> <code>DaoBuilder</code>. (As above, it really cares about
    the <code>DaoDescriptor</code>.)
</p>

<p>
    What does this set-up buy us? Simply this: when we use Hrorm to read or write <code>Recipe</code>
    objects, we can just about ignore the <code>INGREDIENT</code> table entirely. When we call
    <code>Dao.insert()</code>, Hrorm will make sure to insert all the <code>Ingredient</code> objects
    in the <code>Recipe</code> automatically. When we use the <code>Dao.update()</code> method, Hrorm
    will insert, update, and delete <code>Recipe</code> objects without any intervention.
</p>

<h4>Associations</h4>

</body>

</html>